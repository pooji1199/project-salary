# -*- coding: utf-8 -*-
"""empsalaryprediction.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1I71Vbr6SO3IqI7D9Dp5SIcLA7oXuYHu8
"""

#employee salary prediction
#load your library
import pandas as pd
data=pd.read_csv('adult 3.csv')
data

data.shape

data.head()

data.isna()

data.isna().sum()

data.occupation.value_counts()

data.gender.value_counts()

data.education.value_counts()

print(data['marital-status'].value_counts())

print(data['workclass'].value_counts())

data.occupation.replace({'?':'Others'},inplace=True)

data.occupation.value_counts()

data.workclass.replace({'?':'Notlisted'},inplace=True)

print(data.workclass.value_counts())

data=data[data['workclass']!='Without-pay']
data=data[data['workclass']!='Never-worked']

data.workclass.value_counts()

data.shape

data=data[data['education']!='Preschool']
data=data[data['education']!='1st-4th']
data=data[data['education']!='5th-6th']

data.education.value_counts()

data.shape

#redudancy
data.drop(columns=['education'],inplace=True)

data

#outlier
import matplotlib.pyplot as plt
plt.boxplot(data['age'])
plt.show()

data=data[(data['age']<=75)&(data['age']>=17)]

plt.boxplot(data['age'])
plt.show()



#encoding like converting categorical to numerical
from sklearn.preprocessing import LabelEncoder
encoder=LabelEncoder()
data['workclass']=encoder.fit_transform(data['workclass'])
data['capital-gain']=encoder.fit_transform(data['capital-gain'])
data['marital-status']=encoder.fit_transform(data['marital-status'])
data['capital-loss']=encoder.fit_transform(data['capital-loss'])
data['occupation']=encoder.fit_transform(data['occupation'])
data['relationship']=encoder.fit_transform(data['relationship'])
data['race']=encoder.fit_transform(data['race'])
data['gender']=encoder.fit_transform(data['gender'])
data['native-country']=encoder.fit_transform(data['native-country'])

data

data
x=data.drop(columns=['income'])#input variable
y=data['income']#output variable
x

y

from sklearn.preprocessing import MinMaxScaler
scaler=MinMaxScaler()
x=scaler.fit_transform(x)
x

#training we import
from sklearn.model_selection import train_test_split
xtrain,xtest,ytrain,ytest=train_test_split(x,y,test_size=0.2,random_state=23,stratify=y)
xtrain

#machine learning algorithm
from sklearn.neighbors import KNeighborsClassifier
knn=KNeighborsClassifier()
knn.fit(xtrain,ytrain)#we are making model to train from our data
predict=knn.predict(xtest)# our model predicts these values
predict#predicted vaalue

from sklearn.metrics import accuracy_score
accuracy_score(ytest,predict)#checking accuracy how our model is predicting

from sklearn.linear_model import LogisticRegression
lr=LogisticRegression()
lr.fit(xtrain,ytrain)
predict1=lr.predict(xtest)
predict1

from sklearn.metrics import accuracy_score
accuracy_score(ytest,predict1)#checking accuracy how our model is predicting

from sklearn.neural_network import MLPClassifier
clf=MLPClassifier(solver='adam',hidden_layer_sizes=(5,2),random_state=2,max_iter=2000)
clf.fit(xtrain,ytrain)
predict2=clf.predict(xtest)
predict2

from sklearn.metrics import accuracy_score
accuracy_score(ytest,predict2)#checking accuracy how our model is predicting

from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,classification_report
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier,GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.preprocessing import StandardScaler,OneHotEncoder
xtrain,xtest,ytrain,ytest=train_test_split(x,y,test_size=0.2,random_state=23)
model={
    "LogisticRegression":LogisticRegression(),
    "RandomForestClassifier":RandomForestClassifier(),
    "GradientBoostingClassifier":GradientBoostingClassifier(),
    "KNeighborsClassifier":KNeighborsClassifier(),
    "SVC":SVC()
}
results={}
for name,model in model.items():
    pipe=Pipeline([
        ('scaler',StandardScaler()),
        ('model',model)
    ])
    pipe.fit(xtrain,ytrain)
    y_pred=pipe.predict(xtest)
    acc=accuracy_score(ytest,y_pred)
    results[name]=acc
    print(f"{name}Accuracy:{acc:.4f}")
    print(classification_report(ytest,y_pred))

import matplotlib.pyplot as plt
plt.bar(results.keys(), results.values(), color='blue')
plt.ylabel('Accuracy score')
plt.title('Model comparison')
plt.xticks(rotation=45)
plt.grid(True)
plt.show()

from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score,classification_report
from sklearn.linear_model import LogisticRegression
from sklearn.ensemble import RandomForestClassifier,GradientBoostingClassifier
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
import joblib
xtrain,xtest,ytrain,ytest=train_test_split(x,y,test_size=0.2,random_state=42)
models={
    "LogisticRegression":LogisticRegression(),
    "RandomForestClassifier":RandomForestClassifier(),
    "GradientBoostingClassifier":GradientBoostingClassifier(),
    "KNeighborsClassifier":KNeighborsClassifier(),
    "SVM":SVC()
}
results={}
for name, model in models.items():
  model.fit(xtrain,ytrain)
  preds=model.predict(xtest)
  acc=accuracy_score(ytest,preds)
  results[name]=acc
  print(f"{name}:{acc:.4f}")

best_model_name=max(results,key=results.get)
best_model=models[best_model_name]
print(f"\n Best model is {best_model_name} with accuracy {results[best_model_name]:.4f}")
joblib.dump(best_model,'best_model.pkl')
print("saved best model as best_model.pk1")

# Commented out IPython magic to ensure Python compatibility.
# %%writefile app.py
# import streamlit as st
# import pandas as pd
# import joblib
# model=joblib.load('best_model.pkl')
# st.set_page_config(page_title='Employee salary prediction',layout="centred")
# st.title('Employee salary prediction')
# st.markdown("predict whether an employee will earn more than 50k or less than 50k based on input features")
# st.sidebar.header("Input Employee Details")
# age=st.sidebar.slider("Age",18,65,30)
# education=st.sidebar.selectbox("Education level",[
#     "Bachelors","Masters","PhD","HS-grad","Assoc","Some-college"
# ])
# occupation=st.sidebar.selectbox("Job Role",[
#     "Tech-support","Craft-repair","Other","Sales","Exec-managerial","Prof-specialty","Handlers-cleaners","Machine-op-inspct","Adm-clerical","Farming-fishing","Transport-moving","Priv-house-serv","Protective-serv","Armed-Forces"
# ])
# hours_per_week=st.sidebar.slider("Hours per week",1,80,40)
# experience=st.sidebar.slider("Years of experience",0,40,5)
# input_df=pd.DataFrame({
#     'age':[age],
#     'education':[education],
#     'occupation':[occupation],
#     'hours-per-week':[hours_per_week],
#     'experience':[experience]
# })
# st.write("### Input data")
# st.write(input_df)
# if st.button("predict Salary Class"):
#   prediction=model.predict(input_df)
#   st.success(f"prediction:{prediction[0]}")
# st.markdown("---")
# st.markdown("#### Batch prediction")
# uploaded_file=st.file_uploader("Upload a CSV file for batch prediction",type="csv")
# if uploaded_file is not None:
#   batch_data=pd.read_csv(uploaded_file)
#   st.write("Uploaded data preview:",batch_data.head())
#   batch_preds=model.predict(batch_data)
#   batch_data['predictedClass']=batch_preds
#   st.write("Predictions:")
#   st.write(batch_data.head())
#   csv=batch_data.to_csv(index=False).encode('utf-8')
#   st.download_button("Download Predictions CSV",csv,file_name='predicted_classes.csv',mime='text/csv')

!pip install streamlit pyngrok

!ngrok authtoken 306HRhq9SxoGM5YSXIonpDnj2A8_EUu5iCpGmrmNwbBRkmxA

import os
import threading
def run_streamlit():
  os.system('streamlit run app.py -- server.port 8500')
thread=threading.Thread(target=run_streamlit)
thread.start()

from pyngrok import ngrok
import time
time.sleep(5)
public_url=ngrok.connect(8500)
print('your streamlit app is live here:',public_url)